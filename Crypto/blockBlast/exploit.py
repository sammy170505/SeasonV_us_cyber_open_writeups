import socket
import binascii
import time
import sys

HOST = 'crypto.ctf.uscybergames.com'
PORT = 5001
BLOCK_SIZE = 16
TIMEOUT = 3.0  # seconds for socket operations

def recv_until(sock, marker=b'> ', timeout=TIMEOUT):
    sock.settimeout(timeout)
    data = b''
    while marker not in data:
        try:
            more = sock.recv(4096)
            if not more:
                break
            data += more
        except socket.timeout:
            break
    return data

def send_and_recv(sock, msg):
    # Wait for prompt before sending
    recv_until(sock, marker=b'> ')
    sock.sendall(msg + b'\n')
    # Read lines until we get a valid hex string
    while True:
        line = b''
        while not line.endswith(b'\n'):
            try:
                chunk = sock.recv(1)
                if not chunk:
                    break
                line += chunk
            except socket.timeout:
                break
        text = line.strip().decode()
        # Check for hex string (even length, all hex digits)
        if len(text) >= 32 and all(c in '0123456789abcdef' for c in text):
            return binascii.unhexlify(text)
        # If we see the prompt again, something went wrong
        if text.endswith('>'):
            return None

def get_ciphertext(sock, user_bytes):
    hex_input = binascii.hexlify(user_bytes)
    ct = send_and_recv(sock, hex_input)
    return ct

def detect_block_size(sock):
    base = len(get_ciphertext(sock, b'A'))
    for i in range(2, 64):
        clen = len(get_ciphertext(sock, b'A' * i))
        if clen > base:
            return clen - base
    return None

def is_ecb(sock, block_size):
    ct = get_ciphertext(sock, b'A' * (block_size * 2))
    return ct[:block_size] == ct[block_size:2*block_size]

def byte_at_a_time(sock, block_size):
    recovered = b''
    max_flag_len = 128
    for i in range(max_flag_len):
        pad_len = block_size - (len(recovered) % block_size) - 1
        prefix = b'A' * pad_len
        block_index = len(recovered) // block_size
        print(f"[DEBUG] i={i}, pad_len={pad_len}, block_index={block_index}, recovered_len={len(recovered)}")
        print(f"[DEBUG] About to query ciphertext for prefix: {prefix!r} (len={len(prefix)})")
        ct = get_ciphertext(sock, prefix)
        if not ct:
            print("\n[!] Failed to get ciphertext, aborting.")
            break
        target_block = ct[block_index*block_size:(block_index+1)*block_size]

        found = False
        for b in range(256):
            guess = prefix + recovered + bytes([b])
            if pad_len == 0:
                print(f"[DEBUG] Guessing last byte of block: {guess}")
            ct_guess = get_ciphertext(sock, guess)
            if not ct_guess:
                continue
            guess_block = ct_guess[block_index*block_size:(block_index+1)*block_size]
            if guess_block == target_block:
                recovered += bytes([b])
                print(f"Recovered so far ({len(recovered)}): {recovered.decode(errors='replace')}")
                found = True
                break
        if not found:
            print(f"\n[!] No matching byte found at position {i}. Likely end of flag or padding.")
            break
        # If you see a closing brace and the prefix matches, print and stop
        if recovered.endswith(b'}') and (recovered.startswith(b'SVBRG{') or recovered.startswith(b'SVBGR{')):
            print("\n[+] Flag end detected.")
            break
    return recovered


def main():
    with socket.create_connection((HOST, PORT), timeout=TIMEOUT) as sock:
        # Wait for initial banner and prompt
        recv_until(sock, marker=b'> ')
        block_size = detect_block_size(sock)
        if not block_size:
            print("Failed to detect block size. Exiting.")
            sys.exit(1)
        print(f"Detected block size: {block_size}")
        if not is_ecb(sock, block_size):
            print("Not ECB mode, aborting.")
            return
        print("ECB mode confirmed.")
        flag = byte_at_a_time(sock, block_size)
        print(f"\nFlag: {flag.decode(errors='replace')}")
        # Optionally, print next few bytes for debugging
        print("Flag (hex):", flag.hex())

if __name__ == '__main__':
    main()
