import socket
import binascii
import time
import sys

HOST = 'crypto.ctf.uscybergames.com'
PORT = 5001
BLOCK_SIZE = 16
TIMEOUT = 3.0  # seconds for socket operations

def recv_until(sock, marker=b'> ', timeout=TIMEOUT):
    sock.settimeout(timeout)
    data = b''
    while marker not in data:
        try:
            more = sock.recv(4096)
            if not more:
                break
            data += more
        except socket.timeout:
            break
    return data

def send_and_recv(sock, msg):
    # Wait for prompt before sending
    recv_until(sock, marker=b'> ')
    sock.sendall(msg + b'\n')
    # Read lines until we get a valid hex string
    while True:
        line = b''
        while not line.endswith(b'\n'):
            try:
                chunk = sock.recv(1)
                if not chunk:
                    break
                line += chunk
            except socket.timeout:
                break
        text = line.strip().decode()
        # Check for hex string (even length, all hex digits)
        if len(text) >= 32 and all(c in '0123456789abcdef' for c in text):
            return binascii.unhexlify(text)
        # If we see the prompt again, something went wrong
        if text.endswith('>'):
            return None

def get_ciphertext(sock, user_bytes):
    hex_input = binascii.hexlify(user_bytes)
    ct = send_and_recv(sock, hex_input)
    return ct

def detect_block_size(sock):
    base = len(get_ciphertext(sock, b'A'))
    for i in range(2, 64):
        clen = len(get_ciphertext(sock, b'A' * i))
        if clen > base:
            return clen - base
    return None

def is_ecb(sock, block_size):
    ct = get_ciphertext(sock, b'A' * (block_size * 2))
    return ct[:block_size] == ct[block_size:2*block_size]

def byte_at_a_time(sock, block_size):
    recovered = b''
    max_flag_len = 64
    for i in range(max_flag_len):
        pad_len = block_size - (len(recovered) % block_size) - 1
        prefix = b'A' * pad_len
        ct = get_ciphertext(sock, prefix)
        if not ct:
            print("\n[!] Failed to get ciphertext, aborting.")
            break
        block_index = (len(recovered) // block_size)
        target_block = ct[block_index*block_size:(block_index+1)*block_size]

        found = False
        for b in range(32, 127):  # printable ASCII
            guess = prefix + recovered + bytes([b])
            ct_guess = get_ciphertext(sock, guess)
            if not ct_guess:
                continue
            guess_block = ct_guess[block_index*block_size:(block_index+1)*block_size]
            if guess_block == target_block:
                recovered += bytes([b])
                print(f"Recovered: {recovered.decode(errors='replace')}", end='\r')
                found = True
                break
        if not found:
            break
        if recovered.endswith(b'}') and (b'SVBRG{' in recovered or b'SVBGR{' in recovered):
            break
    return recovered

def main():
    with socket.create_connection((HOST, PORT), timeout=TIMEOUT) as sock:
        # Wait for initial banner and prompt
        recv_until(sock, marker=b'> ')
        block_size = detect_block_size(sock)
        if not block_size:
            print("Failed to detect block size. Exiting.")
            sys.exit(1)
        print(f"Detected block size: {block_size}")
        if not is_ecb(sock, block_size):
            print("Not ECB mode, aborting.")
            return
        print("ECB mode confirmed.")
        flag = byte_at_a_time(sock, block_size)
        print(f"\nFlag: {flag.decode(errors='replace')}")

if __name__ == '__main__':
    main()
